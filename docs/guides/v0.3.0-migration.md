# Migrating to rs-pfcp v0.3.0

v0.3.0 introduces three categories of breaking changes:

1. **Error handling** -- all `unmarshal()` and `build()` methods return `Result<T, PfcpError>` instead of `Result<T, io::Error>`
2. **Type-safe newtypes** -- `Seid`, `SequenceNumber`, and `Teid` replace raw `u64`/`u32` in public APIs
3. **Removed deprecated methods** -- `find_ie()` and `find_all_ies()` are gone; use `ies()` instead

Most updates are mechanical search-and-replace. Builders accept `impl Into<Type>`, so **raw integer literals passed to constructors continue to compile unchanged**. MSRV remains 1.90.0.

---

## 1. Error Handling: `io::Error` to `PfcpError`

All `unmarshal()` and `build()` methods now return `Result<T, PfcpError>`.

### Import change

```rust
// v0.2.x
use std::io;

// v0.3.0
use rs_pfcp::error::PfcpError;
```

### Updating error handling

```rust
// v0.2.x
fn handle_message(data: &[u8]) -> Result<(), io::Error> {
    let msg = HeartbeatRequest::unmarshal(data)?;
    Ok(())
}

// v0.3.0
fn handle_message(data: &[u8]) -> Result<(), PfcpError> {
    let msg = HeartbeatRequest::unmarshal(data)?;
    Ok(())
}
```

### Pattern matching on errors

`PfcpError` gives you structured variants instead of opaque `io::Error` strings:

```rust
// v0.2.x
match HeartbeatRequest::unmarshal(data) {
    Ok(msg) => { /* ... */ }
    Err(e) => eprintln!("Parse failed: {}", e),
}

// v0.3.0
match HeartbeatRequest::unmarshal(data) {
    Ok(msg) => { /* ... */ }
    Err(PfcpError::MissingMandatoryIe { ie_type, .. }) => {
        eprintln!("Missing required IE: {:?}", ie_type);
    }
    Err(PfcpError::InvalidLength { ie_name, expected, actual, .. }) => {
        eprintln!("{} too short: expected {} bytes, got {}", ie_name, expected, actual);
    }
    Err(e) => eprintln!("Other error: {}", e),
}
```

### PfcpError variants

| Variant | Description |
|---------|-------------|
| `MissingMandatoryIe` | Required IE not present in message or grouped IE |
| `IeParseError` | IE payload cannot be parsed (invalid format, insufficient data) |
| `InvalidLength` | IE payload too short or incorrect size |
| `InvalidValue` | Field contains an invalid or out-of-range value |
| `ValidationError` | Builder `.build()` validation failure |
| `EncodingError` | UTF-8 decoding failure in IE payload |
| `ZeroLengthNotAllowed` | Zero-length IE rejected per 3GPP TS 29.244 security rules |
| `MessageParseError` | PFCP message structure cannot be parsed |
| `IoError` | Underlying I/O error wrapper |

### Building 3GPP rejection responses

Use `to_cause_code()` to map errors to 3GPP TS 29.244 Cause values:

```rust
use rs_pfcp::ie::cause::CauseValue;

match SessionEstablishmentRequest::unmarshal(data) {
    Ok(msg) => { /* process */ }
    Err(e) => {
        let cause: CauseValue = e.to_cause_code();
        // cause maps to the appropriate 3GPP Cause IE value:
        //   MissingMandatoryIe  -> CauseValue::MandatoryIeMissing  (66)
        //   InvalidLength       -> CauseValue::InvalidLength        (68)
        //   IeParseError        -> CauseValue::MandatoryIeIncorrect (69)
        //   ValidationError     -> CauseValue::RuleCreationModificationFailure (73)
        //   IoError             -> CauseValue::SystemFailure        (77)
        //   MessageParseError   -> CauseValue::RequestRejected      (64)
    }
}
```

### Search-and-replace patterns

- `io::Error` in return types -> `PfcpError`
- `use std::io;` (if only used for errors) -> `use rs_pfcp::error::PfcpError;`
- `io::Error::new(io::ErrorKind::InvalidData, ...)` -> use `PfcpError` constructors like `PfcpError::invalid_value(...)`, `PfcpError::parse_error(...)`, etc.

---

## 2. Type-Safe Newtypes: `Seid`, `SequenceNumber`, `Teid`

Three new types in `rs_pfcp::types` replace raw integers in public APIs:

```rust
use rs_pfcp::types::{Seid, SequenceNumber, Teid};
```

### What still compiles unchanged

Builders and constructors accept `impl Into<Type>`, so raw literals work:

```rust
// This compiles in both v0.2.x and v0.3.0:
let msg = SessionEstablishmentRequestBuilder::new(0x1234u64, 1u32)
    .node_id(Ipv4Addr::new(10, 0, 0, 1))
    .build()?;
```

### What breaks

Code that uses explicit type annotations on values returned from the `Message` trait:

```rust
// v0.2.x
let seid: u64 = msg.seid().unwrap();
let seq: u32 = msg.sequence();

// v0.3.0
let seid: Seid = msg.seid().unwrap();
let seq: SequenceNumber = msg.sequence();
```

### Message trait changes

```rust
// v0.2.x
pub trait Message {
    fn seid(&self) -> Option<u64>;
    fn sequence(&self) -> u32;
    fn set_sequence(&mut self, seq: u32);
    // ...
}

// v0.3.0
pub trait Message {
    fn seid(&self) -> Option<Seid>;
    fn sequence(&self) -> SequenceNumber;
    fn set_sequence(&mut self, seq: SequenceNumber);
    // ...
}
```

### Header struct changes

```rust
// v0.2.x
pub struct Header {
    pub seid: u64,
    pub sequence_number: u32,
    // ...
}

// v0.3.0
pub struct Header {
    pub seid: Seid,
    pub sequence_number: SequenceNumber,
    // ...
}
```

### F-SEID field change

```rust
// v0.2.x
pub struct Fseid {
    pub seid: u64,
    // ...
}

// v0.3.0
pub struct Fseid {
    pub seid: Seid,
    // ...
}
```

### F-TEID field change

```rust
// v0.2.x
pub struct Fteid {
    pub teid: u32,
    // ...
}

// v0.3.0
pub struct Fteid {
    pub teid: Teid,
    // ...
}
```

### Extracting inner values

All three newtypes implement `Deref`, `From`, and `Into`:

```rust
let seid = Seid(0x1234);

// Deref (coerces to &u64 automatically in many contexts)
let raw: u64 = *seid;

// Explicit method
let raw: u64 = seid.value();

// Into conversion
let raw: u64 = seid.into();

// Comparison with literals works via Deref
assert_eq!(*seid, 0x1234u64);
```

### SequenceNumber specifics

`SequenceNumber` masks to 24 bits on construction and provides wrap-around increment:

```rust
let seq = SequenceNumber::new(0xFF123456);
assert_eq!(*seq, 0x123456); // Upper bits masked off

let next = seq.next(); // Wraps at 0x00FFFFFF -> 0
```

### Search-and-replace patterns

- `let seid: u64 = msg.seid()...` -> `let seid: Seid = msg.seid()...` (or remove annotation and let inference work)
- `let seq: u32 = msg.sequence()` -> `let seq: SequenceNumber = msg.sequence()`
- If you need the raw value downstream, add `*seid`, `seid.value()`, or `seid.into()`

---

## 3. Removed Deprecated IE Access Methods

`find_ie()` and `find_all_ies()` were deprecated in v0.2.2 and removed in v0.3.0. Use `ies()` instead.

### Single IE lookup

```rust
// v0.2.x
let node_id = msg.find_ie(IeType::NodeId);

// v0.3.0
let node_id = msg.ies(IeType::NodeId).next();
```

### Collecting all IEs of a type

```rust
// v0.2.x
let pdrs = msg.find_all_ies(IeType::CreatePdr);

// v0.3.0
let pdrs: Vec<&Ie> = msg.ies(IeType::CreatePdr).collect();
```

### Iterating over IEs

```rust
// v0.3.0 â€” iterate directly, no collect() needed
for pdr in msg.ies(IeType::CreatePdr) {
    println!("PDR: {} bytes", pdr.len());
}

// Count without collecting
let count = msg.ies(IeType::CreatePdr).count();
```

### Search-and-replace patterns

- `.find_ie(type)` -> `.ies(type).next()`
- `.find_all_ies(type)` -> `.ies(type).collect::<Vec<_>>()`

---

## Quick Reference

| Area | v0.2.x | v0.3.0 |
|------|--------|--------|
| Error type | `io::Error` | `PfcpError` |
| `msg.seid()` | `Option<u64>` | `Option<Seid>` |
| `msg.sequence()` | `u32` | `SequenceNumber` |
| `header.seid` | `u64` | `Seid` |
| `header.sequence_number` | `u32` | `SequenceNumber` |
| `Fseid.seid` | `u64` | `Seid` |
| `Fteid.teid` | `u32` | `Teid` |
| `msg.find_ie(t)` | `Option<&Ie>` | Removed -- use `msg.ies(t).next()` |
| `msg.find_all_ies(t)` | `Vec<&Ie>` | Removed -- use `msg.ies(t).collect()` |
| Builder params | `u64` / `u32` | `impl Into<Seid>` / `impl Into<SequenceNumber>` (literals still work) |
