//! Advanced Session Management Example - Phase 1-3 Features
//!
//! Demonstrates a complete 5G session lifecycle using new PFCP IEs
//! from Phase 1 (Query URR), Phase 2 (Session Set Management), 
//! and Phase 3 (Network Resilience) implementations.

#![allow(unused_variables, dead_code, unused_imports)]

use rs_pfcp::ie::{
    // New Phase 1-3 IEs
    QueryUrr, TrafficEndpointId, PfcpSessionChangeInfo, SmfSetId,
    PfcpSessionRetentionInformation, UpdateDuplicatingParameters,
    PfcpasRspFlags, UserPlanePathRecoveryReport, GtpuPathQosControlInformation,
    user_plane_path_recovery_report::RemoteGtpuPeer,
    // Core IEs
    NodeId, fseid::Fseid, 
    create_pdr::CreatePdr, create_far::CreateFar, pdi::Pdi, 
    precedence::Precedence, pdr_id::PdrId, far_id::FarId,
};
use rs_pfcp::message::{
    session_establishment_request::SessionEstablishmentRequestBuilder,
    session_establishment_response::SessionEstablishmentResponseBuilder,
    session_modification_request::SessionModificationRequestBuilder,
    association_setup_request::AssociationSetupRequestBuilder,
    association_setup_response::AssociationSetupResponseBuilder,
};
use std::net::Ipv4Addr;
use std::time::SystemTime;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("üåü Advanced Session Management - Complete 5G Lifecycle");
    println!("======================================================");

    // Step 1: Association Setup with High Availability
    association_setup_with_ha()?;
    
    // Step 2: Session Establishment with Multi-Access
    session_establishment_multi_access()?;
    
    // Step 3: Session Modification with Usage Reporting
    session_modification_usage_reporting()?;
    
    // Step 4: Network Resilience and Recovery
    network_resilience_recovery()?;

    println!("\nüéâ Complete 5G session lifecycle demonstrated!");
    println!("üìä Features used: All Phase 1-3 implementations");
    
    Ok(())
}

/// Step 1: Association Setup with High Availability Features
fn association_setup_with_ha() -> Result<(), Box<dyn std::error::Error>> {
    println!("\nü§ù Step 1: Association Setup with High Availability");
    println!("--------------------------------------------------");

    // SMF sends association setup with SMF Set ID for HA
    let smf_set_id = SmfSetId::new("smf-set-region-north-001".to_string());
    let retention_info = PfcpSessionRetentionInformation::new(7200, 0x01); // 2 hours

    let association_request = AssociationSetupRequestBuilder::new(1)
        .node_id(Ipv4Addr::new(10, 1, 0, 100)) // SMF IP
        .recovery_time_stamp(SystemTime::now())
        .build();

    println!("üì§ SMF ‚Üí UPF: Association Setup Request");
    println!("   SMF Set ID: {}", smf_set_id.id);
    println!("   Session Retention: {} seconds", retention_info.retention_time);

    // UPF responds with advanced flags
    let response_flags = PfcpasRspFlags::new(0x00)
        .with_session_retained()
        .with_ip_up_selection();

    let association_response = AssociationSetupResponseBuilder::new(1)
        .cause_accepted()
        .node_id(NodeId::new_ipv4(Ipv4Addr::new(10, 1, 0, 200)).into()) // UPF IP
        .recovery_time_stamp(SystemTime::now())
        .build();

    println!("üì• UPF ‚Üí SMF: Association Setup Response");
    println!("   Session Retained: {}", response_flags.has_session_retained());
    println!("   IP-UP Selection: {}", response_flags.has_ip_up_selection());
    println!("‚úÖ High availability association established");

    Ok(())
}

/// Step 2: Session Establishment with Multi-Access Support
fn session_establishment_multi_access() -> Result<(), Box<dyn std::error::Error>> {
    println!("\nüì± Step 2: Session Establishment with Multi-Access");
    println!("-------------------------------------------------");

    let session_id = 0x123456789ABCDEF0u64;
    let node_id = NodeId::new_ipv4(Ipv4Addr::new(10, 1, 0, 100));
    let fseid = Fseid::new(session_id, Some(Ipv4Addr::new(10, 1, 0, 100)), None);

    // Create PDR for uplink traffic with traffic endpoint
    let uplink_pdi = Pdi::uplink_access()
        .network_instance("internet".to_string())
        .build()?;
    
    let uplink_pdr = CreatePdr::new(PdrId::new(1))
        .precedence(Precedence::new(100))
        .pdi(uplink_pdi.into())
        .far_id(FarId::new(1))
        .build()?;

    // Create FAR for uplink forwarding
    let uplink_far = CreateFar::uplink_to_core(FarId::new(1));

    // Traffic endpoint for multi-access scenarios
    let traffic_endpoint = TrafficEndpointId::new(1);
    
    let session_request = SessionEstablishmentRequestBuilder::new(session_id, 10)
        .node_id(node_id.into())
        .fseid(session_id, Ipv4Addr::new(10, 1, 0, 100))
        .create_pdrs(vec![uplink_pdr.into()])
        .create_fars(vec![uplink_far.into()])
        .build();

    println!("üì§ SMF ‚Üí UPF: Session Establishment Request");
    println!("   Session ID: 0x{:016x}", session_id);
    println!("   Traffic Endpoint ID: {}", traffic_endpoint.id);
    println!("   Multi-access support enabled");

    // UPF responds with session acceptance
    let session_response = SessionEstablishmentResponseBuilder::accepted(session_id, 10)
        .node_id(Ipv4Addr::new(10, 1, 0, 200))
        .fseid(0x987654321FEDCBA0, Ipv4Addr::new(10, 1, 0, 200))
        .build();

    println!("üì• UPF ‚Üí SMF: Session Establishment Response");
    println!("‚úÖ Multi-access session established successfully");

    Ok(())
}

/// Step 3: Session Modification with On-demand Usage Reporting
fn session_modification_usage_reporting() -> Result<(), Box<dyn std::error::Error>> {
    println!("\nüìä Step 3: Session Modification with Usage Reporting");
    println!("---------------------------------------------------");

    let session_id = 0x123456789ABCDEF0u64;

    // SMF requests immediate usage reports from specific URRs
    let query_urr_voice = QueryUrr::new(1); // Voice traffic URR
    let query_urr_data = QueryUrr::new(2);  // Data traffic URR
    let query_urr_video = QueryUrr::new(3); // Video traffic URR

    // Update traffic duplication parameters
    let dup_params = UpdateDuplicatingParameters::new(1) // Core interface
        .with_outer_header_creation(vec![0x40, 0x00, 0x00, 0x00]); // GTP-U header

    let _modification_request = SessionModificationRequestBuilder::new(session_id, 20)
        .query_urrs(vec![
            query_urr_voice.into(),
            query_urr_data.into(),
            query_urr_video.into(),
        ])
        .build();

    println!("üì§ SMF ‚Üí UPF: Session Modification Request");
    println!("   Query URRs: Voice(1), Data(2), Video(3)");
    println!("   Duplication: Interface {}, Header: {:?}", 
             dup_params.destination_interface, 
             dup_params.outer_header_creation);
    println!("‚úÖ On-demand usage reporting requested");

    Ok(())
}

/// Step 4: Network Resilience and Recovery
fn network_resilience_recovery() -> Result<(), Box<dyn std::error::Error>> {
    println!("\nüõ°Ô∏è Step 4: Network Resilience and Recovery");
    println!("------------------------------------------");

    // Session Set Management for bulk operations
    let session_change = PfcpSessionChangeInfo::new(
        0x123456789ABCDEF0, // Session being modified
        2,                  // Change type: handover
    );

    println!("üîÑ Session Set Management:");
    println!("   Session ID: 0x{:016x}", session_change.session_id);
    println!("   Change Type: {} (handover)", session_change.change_type);

    // Path recovery reporting
    let failed_peer = RemoteGtpuPeer {
        destination_interface: 1,
        ipv4_address: Some(Ipv4Addr::new(192, 168, 1, 100)),
        ipv6_address: None,
    };
    let path_recovery = UserPlanePathRecoveryReport::new(failed_peer);

    println!("üîß Path Recovery Report:");
    println!("   Failed Peer: {:?}", path_recovery.remote_gtpu_peer.ipv4_address);
    println!("   Interface: {}", path_recovery.remote_gtpu_peer.destination_interface);

    // Advanced QoS monitoring
    let qos_control = GtpuPathQosControlInformation::new(
        1, // Remote peer identifier
        2, // N3 interface type
        0x04, // Periodic reporting trigger
    );

    println!("üìà QoS Monitoring:");
    println!("   Peer ID: {}", qos_control.remote_gtpu_peer);
    println!("   Interface: N3 (type {})", qos_control.gtpu_path_interface_type);
    println!("   Trigger: 0x{:02x} (periodic)", qos_control.qos_report_trigger);

    println!("‚úÖ Network resilience mechanisms active");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_advanced_session_management() {
        assert!(main().is_ok());
    }

    #[test]
    fn test_individual_steps() {
        assert!(association_setup_with_ha().is_ok());
        assert!(session_establishment_multi_access().is_ok());
        assert!(session_modification_usage_reporting().is_ok());
        assert!(network_resilience_recovery().is_ok());
    }
}
